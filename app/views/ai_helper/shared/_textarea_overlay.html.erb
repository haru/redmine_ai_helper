<%# Auto-completion integration for issue description textarea %>

<%
  # Determine project from @issue if @project is not available
  project = @project || (@issue&.project)
%>
<% if project&.module_enabled?(:ai_helper) && User.current.allowed_to?(:view_ai_helper, project) %>

<!-- Create checkboxes in ERB with proper Redmine sprite_icon -->
<div id="ai-helper-description-checkbox-container" class="ai-helper-autocompletion-controls" style="display: none;">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <span>
      <input type="checkbox" id="ai-helper-autocompletion-description-toggle" />
      <label for="ai-helper-autocompletion-description-toggle">
        <%= sprite_icon("ai-helper-robot", plugin: :redmine_ai_helper) %>
        <%= t('ai_helper.autocompletion.common_toggle_label') %>
      </label>
    </span>

    <!-- Typo check button -->
    <%= link_to "javascript:void(0)", id: "ai-helper-typo-check-description-btn", class: "icon icon-edit" do %>
      <%= sprite_icon("ai-helper-robot", plugin: :redmine_ai_helper) %>
      <%= t('ai_helper.typo_check.check_button') %>
    <% end %>
  </div>
</div>

<script>
  function removeExistingNotesCheckbox() {
    const existingNotesCheckbox = document.getElementById('ai-helper-notes-checkbox-container');
    if (existingNotesCheckbox) {
      existingNotesCheckbox.remove();
    }
  }
  removeExistingNotesCheckbox();
</script>

<% if @issue&.persisted? && !@issue.new_record? %>
<div id="ai-helper-notes-checkbox-container" class="ai-helper-autocompletion-controls" style="display: none;">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <span>
      <input type="checkbox" id="ai-helper-autocompletion-notes-toggle" />
      <label for="ai-helper-autocompletion-notes-toggle">
        <%= sprite_icon("ai-helper-robot", plugin: :redmine_ai_helper) %>
        <%= t('ai_helper.autocompletion.common_toggle_label') %>
      </label>
    </span>

    <!-- Typo check button -->
    <%= link_to "javascript:void(0)", id: "ai-helper-typo-check-notes-btn", class: "icon icon-edit" do %>
      <%= sprite_icon("ai-helper-robot", plugin: :redmine_ai_helper) %>
      <%= t('ai_helper.typo_check.check_button') %>
    <% end %>
  </div>
</div>
<% end %>

<!-- Typo Control Panels for Issue Description and Notes -->
<div id="ai-helper-typo-control-panel-description" class="ai-helper-typo-control-panel" style="display: none;">
  <button type="button" class="ai-helper-typo-apply-all-btn">
    <%= t('ai_helper.typo_check.accept_all') %>
  </button>
  <button type="button" class="ai-helper-typo-close-btn">
    <%= t('ai_helper.typo_check.close') %>
  </button>
</div>

<div id="ai-helper-typo-control-panel-notes" class="ai-helper-typo-control-panel" style="display: none;">
  <button type="button" class="ai-helper-typo-apply-all-btn">
    <%= t('ai_helper.typo_check.accept_all') %>
  </button>
  <button type="button" class="ai-helper-typo-close-btn">
    <%= t('ai_helper.typo_check.close') %>
  </button>
</div>

<script>



function initalizeIssueCompletion() {

  // Prevent multiple initialization by checking if already processed
  if (window.aiHelperAutoCompletionInitialized) {
    return;
  }


  // Find ticket description and notes textarea elements
  const descriptionTextarea = document.getElementById('issue_description');
  const notesTextarea = document.getElementById('issue_notes');


  // Load configuration from YAML file with fallback values
  <%
    config_path = Rails.root.join('plugins', 'redmine_ai_helper', 'config', 'ai_helper', 'config.yml')
    autocompletion_config = {}
    if File.exist?(config_path)
      begin
        config_data = YAML.load_file(config_path)
        autocompletion_config = config_data['autocompletion'] || {}
      rescue => e
        # If YAML loading fails, use default values
        autocompletion_config = {}
      end
    end
  %>
  const config = {
    debounce_delay: <%= autocompletion_config['debounce_delay'] || 500 %>,
    min_length: <%= autocompletion_config['min_length'] || 5 %>,
    suggestion_color: '<%= autocompletion_config['suggestion_color'] || '#888888' %>'
  };

  // Initialize autocompletion for description field
  if (descriptionTextarea && typeof AiHelperAutoCompletion !== 'undefined') {

    const autoCompletion = new AiHelperAutoCompletion(descriptionTextarea, {
      contextType: 'description',
      endpoint: '<%= ai_helper_suggest_completion_path(id: (@issue&.project&.id || @project&.id), issue_id: (@issue&.persisted? ? @issue.id : 'new')) %>',
      debounceDelay: config.debounce_delay,
      minLength: config.min_length,
      suggestionColor: config.suggestion_color,
      // I18n labels
      labels: {
        commonToggleLabel: '<%= t('ai_helper.autocompletion.common_toggle_label') %>',
        loading: '<%= t('ai_helper.autocompletion.loading') %>',
        noSuggestions: '<%= t('ai_helper.autocompletion.no_suggestions') %>',
        acceptSuggestion: '<%= t('ai_helper.autocompletion.accept_suggestion') %>',
        dismiss: '<%= t('ai_helper.autocompletion.dismiss') %>',
        enabledTooltip: '<%= t('ai_helper.autocompletion.enabled_tooltip') %>',
        disabledTooltip: '<%= t('ai_helper.autocompletion.disabled_tooltip') %>'
      }
    });

    autoCompletion.init();

    // Move the description checkbox to below the description textarea

    const descriptionContainer = document.getElementById('ai-helper-description-checkbox-container');

    if (descriptionContainer && descriptionTextarea) {
      const parent = descriptionTextarea.parentNode;
      const nextSibling = descriptionTextarea.nextSibling;
      if (nextSibling) {
        parent.insertBefore(descriptionContainer, nextSibling);
      } else {
        parent.appendChild(descriptionContainer);
      }
      descriptionContainer.style.display = 'block';
    }


    // Store reference globally for potential updates
    if (!window.aiHelperInstances) {
      window.aiHelperInstances = {};
    }
    window.aiHelperInstances.autoCompletion = autoCompletion;
  }

  // Initialize autocompletion for notes field (only for existing issues, not for new issue creation)
  if (notesTextarea && typeof AiHelperAutoCompletion !== 'undefined' && <%= (@issue&.persisted? && !@issue.new_record?) ? 'true' : 'false' %>) {

    const notesAutoCompletion = new AiHelperAutoCompletion(notesTextarea, {
      contextType: 'note',
      endpoint: '<%= @issue&.persisted? ? ai_helper_suggest_completion_path(id: @issue.project.id, issue_id: @issue.id) : '#' %>',
      debounceDelay: config.debounce_delay,
      minLength: config.min_length,
      suggestionColor: config.suggestion_color,
      issueId: '<%= @issue&.id %>',
      projectId: '<%= project&.id %>',
      // I18n labels
      labels: {
        commonToggleLabel: '<%= t('ai_helper.autocompletion.common_toggle_label') %>',
        loading: '<%= t('ai_helper.autocompletion.loading') %>',
        noSuggestions: '<%= t('ai_helper.autocompletion.no_suggestions') %>',
        acceptSuggestion: '<%= t('ai_helper.autocompletion.accept_suggestion') %>',
        dismiss: '<%= t('ai_helper.autocompletion.dismiss') %>',
        enabledTooltip: '<%= t('ai_helper.autocompletion.note_enabled_tooltip') %>',
        disabledTooltip: '<%= t('ai_helper.autocompletion.note_disabled_tooltip') %>'
      }
    });

    notesAutoCompletion.init();

    // Move the notes checkbox to right below the notes textarea

    const notesContainer = document.getElementById('ai-helper-notes-checkbox-container');

    if (notesContainer && notesTextarea) {
      const parent = notesTextarea.parentNode;
      const nextSibling = notesTextarea.nextSibling;

      if (nextSibling) {
        parent.insertBefore(notesContainer, nextSibling);
      } else {
        parent.appendChild(notesContainer);
      }
      notesContainer.style.display = 'block';
    }


    // Store reference globally for potential updates
    if (!window.aiHelperInstances) {
      window.aiHelperInstances = {};
    }
    window.aiHelperInstances.notesAutoCompletion = notesAutoCompletion;
  }

}

// Initialize typo checking with direct button binding
function initializeIssueTypoChecker() {
  const issueDescTextarea = document.getElementById('issue_description');
  const issueNotesTextarea = document.getElementById('issue_notes');
  const descButton = document.getElementById('ai-helper-typo-check-description-btn');
  const notesButton = document.getElementById('ai-helper-typo-check-notes-btn');

  if (typeof AiHelperTypoChecker !== 'undefined') {
    if (issueDescTextarea && descButton) {
      const descTypoChecker = new AiHelperTypoChecker(issueDescTextarea, {
        endpoint: '<%= ai_helper_check_typos_path(project) %>',
        labels: {
          suggestionsTitle: '<%= t('ai_helper.typo_check.suggestions_title') %>',
          noSuggestions: '<%= t('ai_helper.typo_check.no_suggestions') %>',
          checkButton: '<%= t('ai_helper.typo_check.check_button') %>',
          checking: '<%= t('ai_helper.typo_check.checking') %>',
          acceptSuggestion: '<%= t('ai_helper.typo_check.accept_suggestion') %>',
          dismissSuggestion: '<%= t('ai_helper.typo_check.dismiss_suggestion') %>',
          acceptAll: '<%= t('ai_helper.typo_check.accept_all') %>',
          dismissAll: '<%= t('ai_helper.typo_check.dismiss_all') %>',
          errorOccurred: '<%= t('ai_helper.typo_check.error_occurred') %>',
          correctionTooltip: '<%= t('ai_helper.typo_check.correction_tooltip') %>',
          applyFailed: '<%= t('ai_helper.typo_check.apply_failed') %>'
        }
      });
      descTypoChecker.init();

      // Bind existing button directly
      descButton.addEventListener('click', () => {
        descTypoChecker.checkTypos();
      });
    }

    if (issueNotesTextarea && notesButton) {
      const notesTypoChecker = new AiHelperTypoChecker(issueNotesTextarea, {
        endpoint: '<%= ai_helper_check_typos_path(project) %>',
        labels: {
          suggestionsTitle: '<%= t('ai_helper.typo_check.suggestions_title') %>',
          noSuggestions: '<%= t('ai_helper.typo_check.no_suggestions') %>',
          checkButton: '<%= t('ai_helper.typo_check.check_button') %>',
          checking: '<%= t('ai_helper.typo_check.checking') %>',
          acceptSuggestion: '<%= t('ai_helper.typo_check.accept_suggestion') %>',
          dismissSuggestion: '<%= t('ai_helper.typo_check.dismiss_suggestion') %>',
          acceptAll: '<%= t('ai_helper.typo_check.accept_all') %>',
          dismissAll: '<%= t('ai_helper.typo_check.dismiss_all') %>',
          errorOccurred: '<%= t('ai_helper.typo_check.error_occurred') %>',
          correctionTooltip: '<%= t('ai_helper.typo_check.correction_tooltip') %>',
          applyFailed: '<%= t('ai_helper.typo_check.apply_failed') %>'
        }
      });
      notesTypoChecker.init();

      // Bind existing button directly
      notesButton.addEventListener('click', () => {
        notesTypoChecker.checkTypos();
      });
    }
  }
}

setTimeout( function() {
  initalizeIssueCompletion();
  initializeIssueTypoChecker();
}, 500); // Delay to ensure DOM is fully loaded

</script>
<% else %>
<!-- AI Helper auto-completion not available (project module disabled or insufficient permissions) -->
<% end %>

<!-- Hidden templates for typo check buttons -->
<div id="ai-helper-typo-button-templates" style="display: none;">
  <button type="button" class="ai-helper-typo-accept-btn-template"><%= sprite_icon("ai-helper-check", plugin: :redmine_ai_helper) %></button>
  <button type="button" class="ai-helper-typo-reject-btn-template"><%= sprite_icon("ai-helper-x", plugin: :redmine_ai_helper) %></button>
</div>
